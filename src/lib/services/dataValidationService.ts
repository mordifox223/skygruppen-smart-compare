
import { BuifylProduct } from './buifylService';

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  confidence: number; // 0-100
}

export interface DataQualityReport {
  totalProducts: number;
  validProducts: number;
  invalidProducts: number;
  suspiciousProducts: number;
  validationErrors: Array<{
    productId: string;
    providerName: string;
    errors: string[];
  }>;
}

class DataValidationService {
  private knownProviders = {
    mobile: ['Telenor', 'Telia', 'Ice', 'Talkmore', 'OneCall', 'MyCall', 'Chilimobil'],
    electricity: ['Fjordkraft', 'Tibber', 'Hafslund', 'Fortum', 'Lyse', 'NorgesEnergi'],
    insurance: ['If', 'Tryg', 'Gjensidige', 'Fremtind', 'DNB Forsikring', 'Storebrand'],
    loan: ['DNB', 'Nordea', 'Sparebank 1', 'Santander', 'Bank Norwegian']
  };

  private priceRanges = {
    mobile: { min: 99, max: 999 },
    electricity: { min: 50, max: 200 },
    insurance: { min: 200, max: 2000 },
    loan: { min: 1.0, max: 25.0 }
  };

  validateProduct(product: BuifylProduct): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    let confidence = 100;

    // Validate provider name
    const providerValidation = this.validateProvider(product.provider_name, product.category);
    if (!providerValidation.isValid) {
      errors.push(`Ukjent leverandÃ¸r: ${product.provider_name} for kategori ${product.category}`);
      confidence -= 30;
    } else if (providerValidation.isSuspicious) {
      warnings.push(`Mistenkelig leverandÃ¸r: ${product.provider_name}`);
      confidence -= 10;
    }

    // Validate price
    const priceValidation = this.validatePrice(product.monthly_price, product.category);
    if (!priceValidation.isValid) {
      errors.push(`Ugyldig pris: ${product.monthly_price} for kategori ${product.category}`);
      confidence -= 25;
    } else if (priceValidation.isExtreme) {
      warnings.push(`Ekstrem pris: ${product.monthly_price} for ${product.category}`);
      confidence -= 15;
    }

    // Validate plan name vs provider consistency
    if (!this.validatePlanConsistency(product.plan_name, product.provider_name)) {
      warnings.push(`Plan navn "${product.plan_name}" samsvarer ikke med leverandÃ¸r "${product.provider_name}"`);
      confidence -= 10;
    }

    // Validate data freshness
    const dataAge = this.getDataAge(product.scraped_at);
    if (dataAge > 7) {
      warnings.push(`Gamle data: ${dataAge} dager siden oppdatering`);
      confidence -= Math.min(20, dataAge * 2);
    }

    // Validate mobile-specific fields
    if (product.category === 'mobile') {
      const mobileValidation = this.validateMobileProduct(product);
      errors.push(...mobileValidation.errors);
      warnings.push(...mobileValidation.warnings);
      confidence -= mobileValidation.confidencePenalty;
    }

    // Check for auto-generated patterns
    const autoGenValidation = this.detectAutoGenerated(product);
    if (autoGenValidation.isLikelyAutoGenerated) {
      warnings.push('Produktet ser ut til Ã¥ vÃ¦re autogenerert');
      confidence -= 20;
    }

    const isValid = errors.length === 0 && confidence >= 60;
    
    return {
      isValid,
      errors,
      warnings,
      confidence: Math.max(0, confidence)
    };
  }

  private validateProvider(providerName: string, category: string): { isValid: boolean; isSuspicious: boolean } {
    const knownForCategory = this.knownProviders[category as keyof typeof this.knownProviders] || [];
    
    // Exact match
    if (knownForCategory.includes(providerName)) {
      return { isValid: true, isSuspicious: false };
    }

    // Fuzzy match for variations
    const fuzzyMatch = knownForCategory.some(known => 
      this.fuzzyMatch(providerName.toLowerCase(), known.toLowerCase())
    );

    if (fuzzyMatch) {
      return { isValid: true, isSuspicious: true };
    }

    return { isValid: false, isSuspicious: false };
  }

  private validatePrice(price: number, category: string): { isValid: boolean; isExtreme: boolean } {
    const range = this.priceRanges[category as keyof typeof this.priceRanges];
    if (!range) return { isValid: true, isExtreme: false };

    const isValid = price >= range.min && price <= range.max;
    const isExtreme = price < range.min * 0.5 || price > range.max * 2;

    return { isValid, isExtreme };
  }

  private validatePlanConsistency(planName: string, providerName: string): boolean {
    if (!planName || planName === providerName) return true;
    
    // Check if plan name contains provider name or vice versa
    const planLower = planName.toLowerCase();
    const providerLower = providerName.toLowerCase();
    
    return planLower.includes(providerLower) || providerLower.includes(planLower);
  }

  private validateMobileProduct(product: BuifylProduct): { errors: string[]; warnings: string[]; confidencePenalty: number } {
    const errors: string[] = [];
    const warnings: string[] = [];
    let penalty = 0;

    // Validate data allowance format
    if (product.data_allowance) {
      if (!this.isValidDataAllowance(product.data_allowance)) {
        warnings.push(`Ugyldig data format: ${product.data_allowance}`);
        penalty += 5;
      }
    }

    // Validate speed format
    if (product.speed) {
      if (!this.isValidSpeed(product.speed)) {
        warnings.push(`Ugyldig hastighet format: ${product.speed}`);
        penalty += 5;
      }
    }

    return { errors, warnings, confidencePenalty: penalty };
  }

  private detectAutoGenerated(product: BuifylProduct): { isLikelyAutoGenerated: boolean } {
    // Check for generic patterns that suggest auto-generation
    const suspiciousPatterns = [
      /^Plan \d+$/,
      /^Abonnement \d+$/,
      /^Tilbud \d+$/,
      /^LeverandÃ¸r \d+$/
    ];

    const hasGenericName = suspiciousPatterns.some(pattern => 
      pattern.test(product.plan_name) || pattern.test(product.provider_name)
    );

    // Check for rounded prices that might indicate auto-generation
    const hasRoundPrice = product.monthly_price % 50 === 0 || product.monthly_price % 100 === 0;

    // Check for identical features across products (would need to be called with multiple products)
    const hasGenericFeatures = !product.features?.nb || product.features.nb.length === 0;

    return {
      isLikelyAutoGenerated: hasGenericName || (hasRoundPrice && hasGenericFeatures)
    };
  }

  private isValidDataAllowance(data: string): boolean {
    const validPatterns = [
      /^\d+\s*GB$/i,
      /^\d+\s*MB$/i,
      /^Ubegrenset$/i,
      /^Unlimited$/i
    ];
    return validPatterns.some(pattern => pattern.test(data.trim()));
  }

  private isValidSpeed(speed: string): boolean {
    const validPatterns = [
      /^\d+\s*Mbps$/i,
      /^\d+\s*Gbps$/i,
      /^Opp til \d+\s*Mbps$/i
    ];
    return validPatterns.some(pattern => pattern.test(speed.trim()));
  }

  private getDataAge(scrapedAt: string): number {
    const scrapedDate = new Date(scrapedAt);
    const now = new Date();
    const diffTime = Math.abs(now.getTime() - scrapedDate.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }

  private fuzzyMatch(str1: string, str2: string): boolean {
    // Simple fuzzy matching - could be enhanced with Levenshtein distance
    return str1.includes(str2) || str2.includes(str1) || 
           this.removeCommonWords(str1) === this.removeCommonWords(str2);
  }

  private removeCommonWords(str: string): string {
    const commonWords = ['as', 'asa', 'forsikring', 'energi', 'mobil', 'bank'];
    return str.toLowerCase().split(' ')
      .filter(word => !commonWords.includes(word))
      .join(' ');
  }

  validateBatch(products: BuifylProduct[]): DataQualityReport {
    const validationResults = products.map(product => ({
      product,
      validation: this.validateProduct(product)
    }));

    const validProducts = validationResults.filter(r => r.validation.isValid);
    const invalidProducts = validationResults.filter(r => !r.validation.isValid);
    const suspiciousProducts = validationResults.filter(r => 
      r.validation.isValid && r.validation.confidence < 80
    );

    const validationErrors = invalidProducts.map(r => ({
      productId: r.product.id,
      providerName: r.product.provider_name,
      errors: r.validation.errors
    }));

    return {
      totalProducts: products.length,
      validProducts: validProducts.length,
      invalidProducts: invalidProducts.length,
      suspiciousProducts: suspiciousProducts.length,
      validationErrors
    };
  }

  logValidationReport(report: DataQualityReport, category: string): void {
    console.group(`ðŸ“Š Datakvalitetsrapport for ${category}`);
    console.log(`âœ… Gyldige produkter: ${report.validProducts}/${report.totalProducts}`);
    console.log(`âŒ Ugyldige produkter: ${report.invalidProducts}`);
    console.log(`âš ï¸ Mistenkelige produkter: ${report.suspiciousProducts}`);
    
    if (report.validationErrors.length > 0) {
      console.group('ðŸ” Valideringsfeil:');
      report.validationErrors.forEach(error => {
        console.log(`${error.providerName} (${error.productId}):`, error.errors);
      });
      console.groupEnd();
    }
    console.groupEnd();
  }
}

export const dataValidationService = new DataValidationService();
