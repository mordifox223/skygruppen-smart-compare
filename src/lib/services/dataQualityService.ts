
import { supabase } from '@/integrations/supabase/client';
import { BuifylProduct } from './buifylService';

export interface QualityMetrics {
  totalProducts: number;
  validProducts: number;
  hiddenProducts: number;
  lastSync: string;
  averageQuality: number;
  syncErrors: string[];
}

export interface ValidationRule {
  field: string;
  category: string;
  validator: (value: any, product: BuifylProduct) => boolean;
  errorMessage: string;
  severity: 'error' | 'warning';
}

export interface DataStandard {
  mobile: {
    price: { min: number; max: number };
    data_gb: string[];
    networks: string[];
    speeds: string[];
  };
  electricity: {
    price_per_kwh: { min: number; max: number };
    contract_types: string[];
    origins: string[];
  };
  loan: {
    interest_rate: { min: number; max: number };
    loan_amounts: { min: number; max: number };
    terms: number[];
  };
  insurance: {
    monthly_premium: { min: number; max: number };
    coverage_types: string[];
    deductibles: number[];
  };
}

class DataQualityService {
  private standards: DataStandard = {
    mobile: {
      price: { min: 99, max: 999 },
      data_gb: ['Ubegrenset', 'Fri fart', '1GB', '5GB', '10GB', '20GB', '50GB', '100GB'],
      networks: ['Telenor', 'Telia', 'Ice'],
      speeds: ['4G', '5G', '4G+', 'Opp til 100 Mbps', 'Opp til 300 Mbps']
    },
    electricity: {
      price_per_kwh: { min: 0.5, max: 3.0 },
      contract_types: ['Fastpris', 'Spotpris', 'Variabel'],
      origins: ['Vannkraft', 'Vindkraft', 'Solkraft', 'Kjernekraft']
    },
    loan: {
      interest_rate: { min: 1.0, max: 25.0 },
      loan_amounts: { min: 50000, max: 10000000 },
      terms: [12, 24, 36, 60, 120, 240, 360]
    },
    insurance: {
      monthly_premium: { min: 200, max: 2000 },
      coverage_types: ['Kasko', 'Ansvar', 'Delkasko'],
      deductibles: [0, 2000, 4000, 8000, 15000]
    }
  };

  private validationRules: ValidationRule[] = [
    {
      field: 'provider_name',
      category: 'all',
      validator: (value: string) => value && value.length >= 2 && !/^\d+$/.test(value),
      errorMessage: 'Ugyldig leverand√∏rnavn',
      severity: 'error'
    },
    {
      field: 'monthly_price',
      category: 'all',
      validator: (value: number, product) => {
        const standards = this.standards[product.category as keyof DataStandard];
        if (!standards) return true;
        const priceField = product.category === 'electricity' ? 'price_per_kwh' : 
                          product.category === 'loan' ? 'interest_rate' : 
                          product.category === 'insurance' ? 'monthly_premium' : 'price';
        const range = (standards as any)[priceField];
        return range ? value >= range.min && value <= range.max : true;
      },
      errorMessage: 'Pris utenfor forventet omr√•de',
      severity: 'error'
    },
    {
      field: 'data_allowance',
      category: 'mobile',
      validator: (value: string) => {
        if (!value) return true;
        return this.standards.mobile.data_gb.some(allowed => 
          value.toLowerCase().includes(allowed.toLowerCase())
        ) || /^\d+\s*(GB|MB)$/i.test(value);
      },
      errorMessage: 'Ugyldig dataformat',
      severity: 'warning'
    },
    {
      field: 'scraped_at',
      category: 'all',
      validator: (value: string) => {
        const scrapedDate = new Date(value);
        const hoursAgo = (Date.now() - scrapedDate.getTime()) / (1000 * 60 * 60);
        return hoursAgo <= 24;
      },
      errorMessage: 'Data eldre enn 24 timer',
      severity: 'warning'
    }
  ];

  async validateProduct(product: BuifylProduct): Promise<{
    isValid: boolean;
    quality: number;
    errors: string[];
    warnings: string[];
    shouldHide: boolean;
  }> {
    const errors: string[] = [];
    const warnings: string[] = [];
    let quality = 100;

    // Kj√∏r alle valideringsregler
    for (const rule of this.validationRules) {
      if (rule.category !== 'all' && rule.category !== product.category) continue;

      const fieldValue = (product as any)[rule.field];
      const isValid = rule.validator(fieldValue, product);

      if (!isValid) {
        if (rule.severity === 'error') {
          errors.push(rule.errorMessage);
          quality -= 25;
        } else {
          warnings.push(rule.errorMessage);
          quality -= 10;
        }
      }
    }

    // Spesifikk validering per kategori
    quality -= await this.validateCategorySpecifics(product, errors, warnings);

    // Sjekk for autogenererte m√∏nstre
    if (this.isLikelyAutoGenerated(product)) {
      warnings.push('Produktet ser autogenerert ut');
      quality -= 15;
    }

    const finalQuality = Math.max(0, quality);
    const shouldHide = errors.length > 0 || finalQuality < 70;

    return {
      isValid: errors.length === 0,
      quality: finalQuality,
      errors,
      warnings,
      shouldHide
    };
  }

  private async validateCategorySpecifics(
    product: BuifylProduct, 
    errors: string[], 
    warnings: string[]
  ): Promise<number> {
    let qualityPenalty = 0;

    switch (product.category) {
      case 'mobile':
        if (product.speed && !this.standards.mobile.speeds.some(s => 
          product.speed?.toLowerCase().includes(s.toLowerCase())
        )) {
          warnings.push(`Ukjent hastighet: ${product.speed}`);
          qualityPenalty += 5;
        }
        break;

      case 'electricity':
        // Validering for str√∏mleverand√∏rer
        if (product.monthly_price < 0.3 || product.monthly_price > 4.0) {
          errors.push('Str√∏mpris utenfor realistisk omr√•de');
          qualityPenalty += 20;
        }
        break;

      case 'loan':
        // Validering for l√•n
        if (product.monthly_price < 1.0 || product.monthly_price > 30.0) {
          errors.push('Rente utenfor realistisk omr√•de');
          qualityPenalty += 20;
        }
        break;

      case 'insurance':
        // Validering for forsikring
        if (!product.features?.nb || product.features.nb.length === 0) {
          warnings.push('Mangler beskrivelse av dekninger');
          qualityPenalty += 10;
        }
        break;
    }

    return qualityPenalty;
  }

  private isLikelyAutoGenerated(product: BuifylProduct): boolean {
    const suspiciousPatterns = [
      /^Plan \d+$/,
      /^Abonnement \d+$/,
      /^Leverand√∏r \d+$/,
      /^Tilbud \d+$/
    ];

    return suspiciousPatterns.some(pattern => 
      pattern.test(product.plan_name) || pattern.test(product.provider_name)
    ) || (product.monthly_price % 50 === 0 && (!product.features?.nb || product.features.nb.length === 0));
  }

  async syncAndValidateData(): Promise<QualityMetrics> {
    console.log('üîÑ Starter automatisk datasynkronisering og kvalitetskontroll...');

    try {
      // Trigger data refresh
      const { error: syncError } = await supabase.functions.invoke('scrape-real-providers', {
        body: { action: 'scrape_all' }
      });

      if (syncError) {
        console.error('‚ùå Synkroniseringsfeil:', syncError);
      }

      // Hent alle produkter for validering
      const categories = ['mobile', 'electricity', 'insurance', 'loan'];
      let totalProducts = 0;
      let validProducts = 0;
      let hiddenProducts = 0;
      const syncErrors: string[] = [];
      let totalQuality = 0;

      for (const category of categories) {
        const { data: products, error } = await supabase
          .from('provider_offers')
          .select('*')
          .eq('category', category)
          .eq('is_active', true);

        if (error) {
          syncErrors.push(`Feil ved henting av ${category}: ${error.message}`);
          continue;
        }

        for (const product of products || []) {
          totalProducts++;
          const validation = await this.validateProduct(product as BuifylProduct);
          totalQuality += validation.quality;

          if (validation.shouldHide) {
            hiddenProducts++;
            // Skjul produktet midlertidig
            await this.hideProduct(product.id, validation.errors.join(', '));
          } else {
            validProducts++;
          }

          // Logg kritiske feil
          if (validation.errors.length > 0) {
            console.error(`üö® Kritisk feil i ${product.provider_name}:`, validation.errors);
          }
        }
      }

      const metrics: QualityMetrics = {
        totalProducts,
        validProducts,
        hiddenProducts,
        lastSync: new Date().toISOString(),
        averageQuality: totalProducts > 0 ? Math.round(totalQuality / totalProducts) : 0,
        syncErrors
      };

      // Lagre kvalitetsmetrikker
      await this.saveQualityMetrics(metrics);

      console.log('‚úÖ Datasynkronisering og kvalitetskontroll fullf√∏rt:', metrics);
      return metrics;

    } catch (error) {
      console.error('üí• Kritisk feil under synkronisering:', error);
      throw error;
    }
  }

  private async hideProduct(productId: string, reason: string): Promise<void> {
    await supabase
      .from('provider_offers')
      .update({ 
        is_active: false,
        updated_at: new Date().toISOString()
      })
      .eq('id', productId);

    // Logg √•rsaken
    console.log(`üö´ Skjuler produkt ${productId}: ${reason}`);
  }

  private async saveQualityMetrics(metrics: QualityMetrics): Promise<void> {
    // Her kan vi lagre kvalitetsmetrikker til databasen for overv√•king
    console.log('üìä Kvalitetsmetrikker:', metrics);
  }

  async getQualityMetrics(): Promise<QualityMetrics | null> {
    // Implementer henting av siste kvalitetsmetrikker
    return null;
  }

  // Automatisk synkronisering hver 24. time
  startAutoSync(): void {
    console.log('‚è∞ Starter automatisk synkronisering hver 24. time');
    
    setInterval(async () => {
      try {
        await this.syncAndValidateData();
      } catch (error) {
        console.error('‚ùå Feil i automatisk synkronisering:', error);
      }
    }, 24 * 60 * 60 * 1000); // 24 timer
  }
}

export const dataQualityService = new DataQualityService();
